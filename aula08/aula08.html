<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Análise sintática</title>
<meta name="author" content="Construção de compiladores I"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/rodrigo/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="file:///home/rodrigo/reveal.js/dist/theme/white.css" id="theme"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Análise sintática</h1><h2 class="author">Construção de compiladores I</h2>
</section>

<section>
<section id="slide-org52486f4">
<h2 id="org52486f4">Objetivos</h2>
<div class="outline-text-2" id="text-org52486f4">
</div>
</section>
<section id="slide-org8613f7f">
<h3 id="org8613f7f">Objetivos</h3>
<ul>
<li>Introduzir a segunda etapa do front-end: a análise sintática.</li>

<li>Introduzir o conceito de analisadores top-down e bottom-up.</li>

</ul>

</section>
<section id="slide-org109f851">
<h3 id="org109f851">Objetivos</h3>
<ul>
<li>Apresentar a técnica de análise sintática descendente recursiva.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orga220a94">
<h2 id="orga220a94">Análise sintática</h2>
<div class="outline-text-2" id="text-orga220a94">
</div>
</section>
<section id="slide-org978d4ba">
<h3 id="org978d4ba">Análise sintática</h3>
<ul>
<li>Responsável por determinar se o programa atende as restrições sintáticas
da linguagem.</li>

</ul>

</section>
<section id="slide-org48aa8f5">
<h3 id="org48aa8f5">Análise sintática</h3>
<ul>
<li>Regras sintáticas de uma linguagem são expressas utilizando gramáticas livres de contexto.</li>

</ul>

</section>
<section id="slide-org510cec2">
<h3 id="org510cec2">Análise sintática</h3>
<ul>
<li>Porque utilizar GLCs e não ERs?
<ul>
<li>ERs não são capazes de representar construções simples de linguagens.</li>

</ul></li>

</ul>

</section>
<section id="slide-org42bac22">
<h3 id="org42bac22">Análise sintática</h3>
<ul>
<li>Vamos considerar um fragmento de expressões formado por variáveis, constantes inteiras
adição, multiplicação.</li>

</ul>

</section>
<section id="slide-orga7fee4a">
<h3 id="orga7fee4a">Análise sintática</h3>
<ul>
<li>A seguinte ER representa essa linguagem:</li>

</ul>

<div>
\begin{array}{c}
base = [a..z]([a..z] | [0..9])^* \\
base((+|*)base)^*
\end{array}

</div>

</section>
<section id="slide-org9bc7dc5">
<h3 id="org9bc7dc5">Análise sintática</h3>
<ul>
<li>A ER anterior aceita palavras como \(a * b + c\).</li>

<li>Porém, como determinar a precedência entre operadores?</li>

</ul>

</section>
<section id="slide-orgfbdfe53">
<h3 id="orgfbdfe53">Análise sintática</h3>
<ul>
<li>Podemos usar a precedência usual da aritmética.</li>

<li>Porém, não é possível impor uma ordem diferente de avaliação.
<ul>
<li>Para isso, precisamos de parêntesis.</li>

</ul></li>

</ul>

</section>
<section id="slide-org42177ef">
<h3 id="org42177ef">Análise sintática</h3>
<ul>
<li>Ao incluir parêntesis, temos um problema:
<ul>
<li>Como expressar usando ER que parêntesis estão corretos?</li>

</ul></li>

</ul>

</section>
<section id="slide-org103b7de">
<h3 id="org103b7de">Análise sintática</h3>
<ul>
<li>Pode-se provar que a linguagem de parêntesis balanceados não é regular.
<ul>
<li>Usando o lema do bombeamento.</li>
<li>Estrutura similar a \(\{0^n1^n\,|\,n\geq 0\}\).</li>

</ul></li>

</ul>

</section>
<section id="slide-org92cae88">
<h3 id="org92cae88">Análise sintática</h3>
<ul>
<li>Dessa forma, precisamos utilizar GLCs para representar a estrutura sintática
de linguagens.</li>

</ul>

</section>
<section id="slide-org136c88f">
<h3 id="org136c88f">Análise sintática</h3>
<ul>
<li>Antes de apresentar técnicas de análise sintática, vamos revisar alguns
conceitos sobre GLCs.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org97e36f2">
<h2 id="org97e36f2">Gramáticas Livres de Contexto</h2>
<div class="outline-text-2" id="text-org97e36f2">
</div>
</section>
<section id="slide-orgbffbe89">
<h3 id="orgbffbe89">Gramáticas livres de contexto</h3>
<ul>
<li>Uma GLC é \(G=(V,\Sigma,R,P)\), em que
<ul>
<li>\(V\): conjunto de variáveis (não terminais)</li>
<li>\(\Sigma\): alfabeto (terminais)</li>
<li>\(R \subseteq V\times (V\cup\Sigma)^*\): regras (produções).</li>
<li>\(P\in V\): variável de partida.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgb4257d6">
<h3 id="orgb4257d6">Gramáticas livres de contexto</h3>
<ul>
<li>Gramática de expressões</li>

</ul>

<div>
\begin{array}{lcl}
E & \to & (E) \,|\, E + E \,|\, E * E\,|\, num\,|\,var\\
\end{array}

</div>

</section>
<section id="slide-orgebc3466">
<h3 id="orgebc3466">Gramáticas livres de contexto</h3>
<ul>
<li>\(V = \{E\}\)</li>
<li>\(\Sigma = \{num, var, (, ), *, +\}\)</li>
<li>\(R\): conjunto de regras da gramática.</li>

</ul>

</section>
<section id="slide-org06a2f78">
<h3 id="org06a2f78">Gramáticas livres de contexto</h3>
<ul>
<li>Determinamos se uma palavra pertence ou não à linguagem
de uma gramática construindo uma <b>derivação</b></li>

</ul>

</section>
<section id="slide-org5adecae">
<h3 id="org5adecae">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow &
\end{array}

</div>


</section>
<section id="slide-org3a8541d">
<h3 id="org3a8541d">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   \\
\end{array}

</div>



</section>
<section id="slide-org80b1db4">
<h3 id="org80b1db4">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   & \Rightarrow & \textbf{regra } E \to num\\
\end{array}

</div>


</section>
<section id="slide-orga5304db">
<h3 id="orga5304db">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   & \Rightarrow & \textbf{regra } E \to num\\
num + E \\
\end{array}

</div>


</section>
<section id="slide-org9a53e1c">
<h3 id="org9a53e1c">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   & \Rightarrow & \textbf{regra } E \to num\\
num + E & \Rightarrow & \textbf{regra } E \to E * E\\
num + E * E\\
\end{array}

</div>


</section>
<section id="slide-org6577f99">
<h3 id="org6577f99">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   & \Rightarrow & \textbf{regra } E \to num\\
num + E & \Rightarrow & \textbf{regra } E \to E * E\\
num + E * E & \Rightarrow & \textbf{regra } E \to num\\
\end{array}

</div>


</section>
<section id="slide-orgcdb27f6">
<h3 id="orgcdb27f6">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   & \Rightarrow & \textbf{regra } E \to num\\
num + E & \Rightarrow & \textbf{regra } E \to E * E\\
num + E * E & \Rightarrow & \textbf{regra } E \to num\\
num + num * E \\
\end{array}

</div>


</section>
<section id="slide-orga8c78fa">
<h3 id="orga8c78fa">Gramáticas livres de contexto</h3>
<ul>
<li>Exemplo: Derivação de \(num + num * num\).</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E + E\\
E + E   & \Rightarrow & \textbf{regra } E \to num\\
num + E & \Rightarrow & \textbf{regra } E \to E * E\\
num + E * E & \Rightarrow & \textbf{regra } E \to num\\
num + num * E & \Rightarrow & \textbf{regra } E \to num \\
num + num * num
\end{array}

</div>

</section>
<section id="slide-orgbb82d77">
<h3 id="orgbb82d77">Gramáticas livres de contexto</h3>
<ul>
<li>O exemplo anterior foi de uma <b>derivação mais à esquerda</b>
<ul>
<li>Expande-se o não terminal mais a esquerda.</li>

</ul></li>

</ul>

</section>
<section id="slide-org8ce2092">
<h3 id="org8ce2092">Gramáticas livres de contexto</h3>
<ul>
<li>Note que essa gramática de expressões permite:</li>

</ul>

<div>
\begin{array}{lcl}
E       & \Rightarrow & \textbf{regra } E\to E * E\\
E * E   \\
\end{array}

</div>

</section>
<section id="slide-org4ec4663">
<h3 id="org4ec4663">Gramáticas livres de contexto</h3>
<ul>
<li>Com isso temos <b>duas</b> derivações distintas para a mesma palavra.</li>

<li>Isso torna a gramática de exemplo <b>ambígua</b>.</li>

</ul>

</section>
<section id="slide-org4e11eca">
<h3 id="org4e11eca">Gramáticas livres de contexto</h3>
<ul>
<li>Árvores de derivação: representação hierárquica da derivação.</li>

</ul>


<div id="orgf2d09b9" class="figure">
<p><img src="./imgs/image1.png" alt="image1.png" />
</p>
</div>

</section>
<section id="slide-org9e08966">
<h3 id="org9e08966">Gramáticas livres de contexto</h3>
<ul>
<li>Em algumas situações é necessário modificar regras de uma gramática para usar certas técnicas de análise sintática.</li>

<li>Veremos algumas dessas técnicas.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org678814d">
<h2 id="org678814d">Transformações de gramáticas</h2>
<div class="outline-text-2" id="text-org678814d">
</div>
</section>
<section id="slide-org9d2a221">
<h3 id="org9d2a221">Transformações de gramáticas</h3>
<ul>
<li>Fatoração à esquerda: Evitar mais de uma regra com o mesmo prefixo</li>

</ul>

</section>
<section id="slide-org27e3b63">
<h3 id="org27e3b63">Transformações de gramáticas</h3>
<ul>
<li>Exemplo:</li>

</ul>

<div>
\begin{array}{lcl}
  A & \to & xz \,|\, xy\,|\,v
\end{array}

</div>

<ul>
<li>pode ser transformada em:</li>

</ul>

<div>
\begin{array}{lcl}
  A & \to & xZ\,|\,v\\
  Z & \to & z \,|\,y
\end{array}

</div>

</section>
<section id="slide-org0acab79">
<h3 id="org0acab79">Transformações de gramáticas</h3>
<ul>
<li>Introdução de prioridades.
<ul>
<li>Problema comum em linguagens de programação com operadores.</li>
<li>Impor ordem de precedência na ausência de parêntesis.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgfa9a63a">
<h3 id="orgfa9a63a">Transformações de gramáticas</h3>
<ul>
<li>Forma geral para introduzir prioridades:
<ul>
<li>\(E_i\): expressões com precedência de nível \(i\).</li>
<li>Maior precedência: mais profundo.</li>

</ul></li>

</ul>

<div>
\begin{array}{lcl}
E_i & \to & E_{i + 1} \,|\, E_i Op_i E_{i + 1}
\end{array}

</div>

</section>
<section id="slide-orgc47ee47">
<h3 id="orgc47ee47">Transformações de gramáticas</h3>
<ul>
<li>Eliminar recursão à esquerda
<ul>
<li>Transformar em recursão à direita.</li>

</ul></li>

</ul>

<div>
\begin{array}{lcl}
A & \to & Ay_1\,|\,...\,|\,Ay_n\,|\,w_1\,|\,...\,|\,w_k\\
\end{array}

</div>

</section>
<section id="slide-org23ddf7e">
<h3 id="org23ddf7e">Transformações de gramáticas</h3>
<ul>
<li>Pode ser transformada em</li>

</ul>

<div>
\begin{array}{lcl}
A & \to & y_1Z\,|\,...\,|\,y_nZ\,|\,y_1\,...\,|\,y_n\\
Z & \to & w_1Z\,|\,...\,|\,w_kZ\,|\,w_1\,...\,|\,w_k\\
\end{array}

</div>

</section>
<section id="slide-org2a4d4a0">
<h3 id="org2a4d4a0">Transformações de gramáticas</h3>
<ul>
<li>Exemplo:
<ul>
<li>\(*\) tem prioridade maior que \(+\)</li>

</ul></li>

</ul>

<div>
\begin{array}{lcl}
E & \to & num \,|\,var\,|\,(E)\,|\,E+E\,|\,E * E\\
\end{array}

</div>


</section>
<section id="slide-org4d77624">
<h3 id="org4d77624">Transformações de gramáticas</h3>
<ul>
<li>Exemplo:
<ul>
<li>\(*\) tem prioridade maior que \(+\)</li>

</ul></li>

</ul>

<div>
\begin{array}{lcl}
E_1 & \to & E_2\,|\,E_1 + E_2\\
E_2 & \to & E_3\,|\,E_2 * E_3\\
E_3 & \to & num\,|\,var\,|\,(E_1)\\
\end{array}

</div>

</section>
<section id="slide-orga83f74d">
<h3 id="orga83f74d">Transformação de gramáticas</h3>
<ul>
<li>Eliminar recursão a esquerda.
<ul>
<li>Resolução no quadro</li>

</ul></li>

</ul>

<div>
\begin{array}{lcl}
   S & \to & Aa\,|\,b\\
   A & \to & Ac\,|\,Sd\,|\,\lambda\\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org64a4a46">
<h2 id="org64a4a46">Análise sintática</h2>
<div class="outline-text-2" id="text-org64a4a46">
</div>
</section>
<section id="slide-org010073b">
<h3 id="org010073b">Análise sintática</h3>
<ul>
<li>Dois tipos de algoritmos:
<ul>
<li>Análise sintática top-down</li>
<li>Análise sintática bottom-up</li>

</ul></li>

</ul>

</section>
<section id="slide-org420e74c">
<h3 id="org420e74c">Análise sintática</h3>
<ul>
<li>Analisador sintático top-down
<ul>
<li>Inicia a partir do símbolo de partida da gramática.</li>
<li>A cada passo, escolhe um não terminal para expandir até
<ul>
<li>Obter o programa de entrada.</li>
<li>Encontrar um erro.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org7a9aa89">
<h3 id="org7a9aa89">Análise sintática</h3>
<ul>
<li>Analisador sintático bottom-up
<ul>
<li>Inicia a partir das folhas</li>
<li>Encontra substrings da palavra e encontra um lado direito de regra correspondente.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgda47c6f">
<h3 id="orgda47c6f">Análise sintática</h3>
<ul>
<li>Nesta aula, vamos focar em uma técnica top-down.
<ul>
<li>Analisador sintático descendente recursivo.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6c18cc3">
<h2 id="org6c18cc3">Análise descendente</h2>
<div class="outline-text-2" id="text-org6c18cc3">
</div>
</section>
<section id="slide-org202f2fb">
<h3 id="org202f2fb">Análise descendente</h3>
<ul>
<li>Técnica simples para codificação manual de analisadores sintáticos.</li>

<li>Gramáticas são representadas por um conjunto de funções
<ul>
<li>Uma função para cada não terminal.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgef4f625">
<h3 id="orgef4f625">Análise descendente</h3>
<ul>
<li>Analisador para \(A \to X_1 ... X_n\):
<ul>
<li>Para \(i = 1\) até \(k\)
<ul>
<li>Se \(X_i\) for uma variável, chame a função correspondente a \(X_i\).</li>
<li>Se \(X_i\) for um terminal, verifique se ele é igual ao primeiro token da entrada.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org7077228">
<h3 id="org7077228">Análise descendente</h3>
<ul>
<li>Vantagem:
<ul>
<li>Codificação simples e de fácil compreensão.</li>

</ul></li>

<li>Problemas:
<ul>
<li>Não permite gramática com recursão à esquerda.</li>

</ul></li>

</ul>

</section>
<section id="slide-org36251b8">
<h3 id="org36251b8">Análise descendente</h3>
<ul>
<li>Em Haskell, analisadores descendentes são codificados por combinadores.</li>

</ul>

</section>
<section id="slide-orgdff47de">
<h3 id="orgdff47de">Análise descendente</h3>
<ul>
<li>Combinadores são uma EDSL para expressar gramáticas.
<ul>
<li>Dúzias de bibliotecas: <code>megaparsec</code>, <code>parser-combinators</code>, <code>uu-parselib</code>, etc&#x2026;</li>

</ul></li>

</ul>

</section>
<section id="slide-org15669f0">
<h3 id="org15669f0">Análise descendente</h3>
<ul>
<li>Veremos uma implementação simples de uma EDSL para gramáticas.</li>

</ul>

</section>
<section id="slide-org3242a97">
<h3 id="org3242a97">Análise descendente</h3>
<ul>
<li>Representação de parsers</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">newtype</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> s a <span style="color: #7590db;">=</span>
  <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">{</span> runParser <span style="color: #7590db;">::</span> <span style="color: #bc6ec5;">[</span>s<span style="color: #bc6ec5;">]</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5;">[</span><span style="color: #2d9574;">(</span>a,<span style="color: #67b11d;">[</span>s<span style="color: #67b11d;">]</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">]</span> <span style="color: #4f97d7;">}</span>
</pre>
</div>

</section>
<section id="slide-org104fa7c">
<h3 id="org104fa7c">Análise descendente</h3>
<ul>
<li>Parsers são functores</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">instance</span> <span style="color: #ce537a; font-weight: bold;">Functor</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Parser</span> s<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">where</span>
  fmap f p <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span> s <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5;">[</span><span style="color: #2d9574;">(</span>f x, s'<span style="color: #2d9574;">)</span> <span style="color: #7590db;">|</span> <span style="color: #2d9574;">(</span>x,s'<span style="color: #2d9574;">)</span> <span style="color: #7590db;">&lt;-</span> runParser p s<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span> 
</pre>
</div>

</section>
<section id="slide-orgb550f3f">
<h3 id="orgb550f3f">Análise descendente</h3>
<ul>
<li>Parsers são applicatives</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">instance</span> <span style="color: #ce537a; font-weight: bold;">Applicative</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Parser</span> s<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">where</span>
  pure  a <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span>ts <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5;">[</span><span style="color: #2d9574;">(</span>a, ts<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>
  p1 <span style="color: #7590db;">&lt;*&gt;</span> p2 <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span> s <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5;">[</span><span style="color: #2d9574;">(</span>f x, s2<span style="color: #2d9574;">)</span> <span style="color: #7590db;">|</span> <span style="color: #2d9574;">(</span>f, s1<span style="color: #2d9574;">)</span> <span style="color: #7590db;">&lt;-</span> runParser p1 s,
                                          <span style="color: #2d9574;">(</span>x, s2<span style="color: #2d9574;">)</span> <span style="color: #7590db;">&lt;-</span> runParser p2 s1<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orgba17c41">
<h3 id="orgba17c41">Análise descendente</h3>
<ul>
<li>Parsers são alternatives</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">instance</span> <span style="color: #ce537a; font-weight: bold;">Alternative</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Parser</span> t<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">where</span>
  empty <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5; font-weight: bold;">[]</span><span style="color: #4f97d7;">)</span>
  p1 <span style="color: #7590db;">&lt;|&gt;</span> p2 <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span> s <span style="color: #7590db;">-&gt;</span> runParser p1 s <span style="color: #7590db;">++</span> runParser p2 s<span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-org804a992">
<h3 id="org804a992">Análise descendente</h3>
<ul>
<li>Parsers são mônadas</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">instance</span> <span style="color: #ce537a; font-weight: bold;">Monad</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Parser</span> t<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">where</span>
  return <span style="color: #7590db;">=</span>  pure
  p <span style="color: #7590db;">&gt;&gt;=</span> f  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span>ts <span style="color: #7590db;">-&gt;</span> concat <span style="color: #bc6ec5;">[</span> runParser <span style="color: #2d9574;">(</span>f a<span style="color: #2d9574;">)</span> cs' <span style="color: #7590db;">|</span>
                                     <span style="color: #2d9574;">(</span>a,cs'<span style="color: #2d9574;">)</span> <span style="color: #7590db;">&lt;-</span> runParser p ts <span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orgb097724">
<h3 id="orgb097724">Análise descendente</h3>
<ul>
<li>Processando o primeiro token da entrada</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">item</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> t t
<span style="color: #bc6ec5; font-weight: bold;">item</span> <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #4f97d7;">(</span><span style="color: #7590db;">\</span> ts <span style="color: #7590db;">-&gt;</span>
                 <span style="color: #4f97d7; font-weight: bold;">case</span> ts <span style="color: #4f97d7; font-weight: bold;">of</span>
                   <span style="color: #bc6ec5; font-weight: bold;">[]</span>     <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5; font-weight: bold;">[]</span>
                   <span style="color: #bc6ec5;">(</span>c<span style="color: #ce537a; font-weight: bold;">:</span>cs<span style="color: #bc6ec5;">)</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #bc6ec5;">[</span><span style="color: #2d9574;">(</span>c,cs<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orgd2aadc3">
<h3 id="orgd2aadc3">Análise descendente</h3>
<ul>
<li>Processando um token que satisfaz uma condição.</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">sat</span> <span style="color: #7590db;">::</span> <span style="color: #4f97d7;">(</span>t <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Bool</span><span style="color: #4f97d7;">)</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> t t
<span style="color: #bc6ec5; font-weight: bold;">sat</span> p <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">do</span>
          t <span style="color: #7590db;">&lt;-</span> item
          <span style="color: #4f97d7; font-weight: bold;">if</span> p t <span style="color: #4f97d7; font-weight: bold;">then</span> return t <span style="color: #4f97d7; font-weight: bold;">else</span> mzero
</pre>
</div>

</section>
<section id="slide-org889d79a">
<h3 id="org889d79a">Análise descendente</h3>
<ul>
<li>Processando um certo token.</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">symbol</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Eq</span> s <span style="color: #7590db;">=&gt;</span> s <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> s s
<span style="color: #bc6ec5; font-weight: bold;">symbol</span> c <span style="color: #7590db;">=</span> sat <span style="color: #4f97d7;">(</span>c <span style="color: #7590db;">==</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orga902bbf">
<h3 id="orga902bbf">Análise descendente</h3>
<ul>
<li>Devido a lazy evaluation, podemos entender recursão à esquerda em expressões como uma lista de separadores.</li>

<li>Ideia sumarizada pela ER: \(E(op\:E)^*\)</li>

</ul>

</section>
<section id="slide-org384e14f">
<h3 id="org384e14f">Análise descendente</h3>
<ul>
<li>Função <code>chainl</code></li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">chainl</span>  <span style="color: #7590db;">::</span>  <span style="color: #ce537a; font-weight: bold;">Parser</span> s a <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> s <span style="color: #4f97d7;">(</span>a <span style="color: #7590db;">-&gt;</span> a <span style="color: #7590db;">-&gt;</span> a<span style="color: #4f97d7;">)</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> s a
<span style="color: #bc6ec5; font-weight: bold;">chainl</span> pe po  <span style="color: #7590db;">=</span>  h <span style="color: #7590db;">&lt;$&gt;</span> pe <span style="color: #7590db;">&lt;*&gt;</span> many <span style="color: #4f97d7;">(</span>j <span style="color: #7590db;">&lt;$&gt;</span> po <span style="color: #7590db;">&lt;*&gt;</span> pe<span style="color: #4f97d7;">)</span>
  <span style="color: #4f97d7; font-weight: bold;">where</span> j op x  <span style="color: #7590db;">=</span>  <span style="color: #4f97d7;">(</span><span style="color: #7590db;">`op`</span> x<span style="color: #4f97d7;">)</span>
        h x fs  <span style="color: #7590db;">=</span>  foldl <span style="color: #4f97d7;">(</span>flip <span style="color: #bc6ec5;">(</span><span style="color: #7590db;">$</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> x fs
</pre>
</div>

</section>
<section id="slide-org1485b9a">
<h3 id="org1485b9a">Análise descendente</h3>
<ul>
<li>Automatizando parsers de expressões</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">type</span> <span style="color: #ce537a; font-weight: bold;">Op</span> s a <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">(</span>s, a <span style="color: #7590db;">-&gt;</span> a <span style="color: #7590db;">-&gt;</span> a<span style="color: #4f97d7;">)</span>

<span style="color: #bc6ec5; font-weight: bold;">gen</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Eq</span> s <span style="color: #7590db;">=&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Op</span> s a<span style="color: #4f97d7;">]</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> s a <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> s a
<span style="color: #bc6ec5; font-weight: bold;">gen</span> ops p <span style="color: #7590db;">=</span> chainl p <span style="color: #4f97d7;">(</span>choice <span style="color: #bc6ec5;">(</span>map f ops<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    f <span style="color: #4f97d7;">(</span>s,c<span style="color: #4f97d7;">)</span> <span style="color: #7590db;">=</span> const c <span style="color: #7590db;">&lt;$&gt;</span> symbol s
</pre>
</div>

</section>
<section id="slide-org637387e">
<h3 id="org637387e">Análise descendente</h3>
<ul>
<li>Tipo do token</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Token</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Id</span> <span style="color: #ce537a; font-weight: bold;">String</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Number</span> <span style="color: #ce537a; font-weight: bold;">Int</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Add</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Mult</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">LParen</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">RParen</span>
  <span style="color: #4f97d7; font-weight: bold;">deriving</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Eq</span>, <span style="color: #ce537a; font-weight: bold;">Show</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-org3e74f03">
<h3 id="org3e74f03">Análise descendente</h3>
<ul>
<li>Tipo de expressões</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Expr</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Var</span> <span style="color: #ce537a; font-weight: bold;">String</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Lit</span> <span style="color: #ce537a; font-weight: bold;">Int</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Expr</span> <span style="color: #ce537a; font-weight: bold;">:+:</span> <span style="color: #ce537a; font-weight: bold;">Expr</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Expr</span> <span style="color: #ce537a; font-weight: bold;">:*:</span> <span style="color: #ce537a; font-weight: bold;">Expr</span>
  <span style="color: #4f97d7; font-weight: bold;">deriving</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Eq</span>, <span style="color: #ce537a; font-weight: bold;">Show</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-org239c181">
<h3 id="org239c181">Análise descendente</h3>
<ul>
<li>Criando o parser de expressões</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">exprParser</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #ce537a; font-weight: bold;">Token</span> <span style="color: #ce537a; font-weight: bold;">Expr</span>
<span style="color: #bc6ec5; font-weight: bold;">exprParser</span> <span style="color: #7590db;">=</span> addtable <span style="color: #7590db;">`gen`</span> termParser
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    addtable <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Add</span>, <span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">:+:</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span>
</pre>
</div>

</section>
<section id="slide-org3b244b3">
<h3 id="org3b244b3">Análise descendente</h3>
<ul>
<li>Parser para termos</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">termParser</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #ce537a; font-weight: bold;">Token</span> <span style="color: #ce537a; font-weight: bold;">Expr</span>
<span style="color: #bc6ec5; font-weight: bold;">termParser</span> <span style="color: #7590db;">=</span> multable <span style="color: #7590db;">`gen`</span> factParser
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    multable <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Mult</span>, <span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">:*:</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span>
</pre>
</div>

</section>
<section id="slide-org2e41ce9">
<h3 id="org2e41ce9">Análise descendente</h3>
<ul>
<li>Parser para fatores</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">factParser</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Parser</span> <span style="color: #ce537a; font-weight: bold;">Token</span> <span style="color: #ce537a; font-weight: bold;">Expr</span>
<span style="color: #bc6ec5; font-weight: bold;">factParser</span> <span style="color: #7590db;">=</span> numParser  <span style="color: #7590db;">&lt;|&gt;</span>
             varParser  <span style="color: #7590db;">&lt;|&gt;</span>
             parenExpr
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    parenExpr <span style="color: #7590db;">=</span> pack lparen exprParser rparen
    lparen <span style="color: #7590db;">=</span> symbol <span style="color: #ce537a; font-weight: bold;">LParen</span>
    rparen <span style="color: #7590db;">=</span> symbol <span style="color: #ce537a; font-weight: bold;">RParen</span>
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org81d01b7">
<h2 id="org81d01b7">Concluindo</h2>
<div class="outline-text-2" id="text-org81d01b7">
</div>
</section>
<section id="slide-org339ff07">
<h3 id="org339ff07">Concluindo</h3>
<ul>
<li>Apresentamos uma introdução à análise sintática.</li>

<li>Revisamos sobre GLCs e transformações sobre estas.</li>

</ul>

</section>
<section id="slide-orgccfd00a">
<h3 id="orgccfd00a">Concluindo</h3>
<ul>
<li>Apresentamos a técnica de análise sintática descendente recursiva.</li>

<li>Em Haskell, esta técnica é representada por combinadores.</li>

</ul>

</section>
<section id="slide-orgca91f8f">
<h3 id="orgca91f8f">Concluindo</h3>
<ul>
<li>Próxima aula: análise sintática LL(1).</li>

</ul>

</section>
</section>
<section>
<section id="slide-orge32d535">
<h2 id="orge32d535">Exercícios</h2>
<div class="outline-text-2" id="text-orge32d535">
</div>
</section>
<section id="slide-orgd732173">
<h3 id="orgd732173">Exercícios</h3>
<ul>
<li>Construa um analisador sintático descendente recursivo para seguinte
linguagem de fórmulas da lógica proposicional.</li>

</ul>

<div>
\begin{array}{lcl}
F & \to & \textbf{true}\,|\,\textbf{false}\,|\,\textbf{not }\,F\,|\,F\:\:\textbf{/\\}\:\:F\,|\,F\:\:\textbf{\\/}\:\:F\\
\end{array}

</div>
</section>
</section>
</div>
</div>
<script src="file:///home/rodrigo/reveal.js/dist/reveal.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/markdown/markdown.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/notes/notes.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/search/search.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'convex',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
