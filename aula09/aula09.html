<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Conjuntos first e follow</title>
<meta name="author" content="Construção de compiladores I"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/rodrigo/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="file:///home/rodrigo/reveal.js/dist/theme/white.css" id="theme"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Conjuntos first e follow</h1><h2 class="author">Construção de compiladores I</h2>
</section>


<section>
<section id="slide-org4c8ec85">
<h2 id="org4c8ec85">Objetivos</h2>
<div class="outline-text-2" id="text-org4c8ec85">
</div>
</section>
<section id="slide-org746e33f">
<h3 id="org746e33f">Objetivos</h3>
<ul>
<li>Apresentar os conjuntos first e follow e seu uso para definir gramáticas LL(1)</li>

<li>Apresentar uma implementação de first e follow em Haskell.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf189bae">
<h2 id="orgf189bae">Gramáticas LL(1)</h2>
<div class="outline-text-2" id="text-orgf189bae">
</div>
</section>
<section id="slide-org4ac1216">
<h3 id="org4ac1216">Gramáticas LL(1)</h3>
<ul>
<li>Classe de gramáticas que admitem analisadores sem backtracking</li>

<li>LL(1) significa
<ul>
<li>*L*eft to right: entrada analisada da esquerda para direita.</li>
<li>*L*eft most derivation: construção de derivação mais a esquerda.</li>
<li>Uso de <b>1</b> token da entrada para decidir a derivação.</li>

</ul></li>

</ul>

</section>
<section id="slide-org5e4e8e7">
<h3 id="org5e4e8e7">Gramáticas LL(1)</h3>
<ul>
<li>Como determinar se uma gramática é LL(1)?
<ul>
<li>Vamos usar os conjuntos First e Follow.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org9398ff5">
<h2 id="org9398ff5">First e Follow</h2>
<div class="outline-text-2" id="text-org9398ff5">
</div>
</section>
<section id="slide-orgdb359f8">
<h3 id="orgdb359f8">First e Follow</h3>
<ul>
<li>\(first(\alpha)\): conjunto de terminais que iniciam sentenças derivadas a partir de \(\alpha\).</li>

<li>\(\alpha \in (V\cup \Sigma)^*\).</li>

</ul>

</section>
<section id="slide-org4f66022">
<h3 id="org4f66022">First e Follow</h3>
<ul>
<li>\(follow(A)\): conjunto de terminais que aparecem logo a direita de \(A\) em alguma derivação.</li>

<li>\(A \in V\).</li>

</ul>

</section>
<section id="slide-org19106a4">
<h3 id="org19106a4">First e Follow</h3>
<ul>
<li>\(first(a) = \{a\}\), se \(a \in \Sigma\).</li>
<li>\(\lambda\in first(A)\) se \(A\to\lambda \in R\).</li>

</ul>

</section>
<section id="slide-org9e27e23">
<h3 id="org9e27e23">First e Follow</h3>
<ul>
<li>Se \(A \in V\) e</li>
<li>\(A \to Y_1\,Y_2\,...\,Y_k \in R\) e</li>
<li>\(a\in first(Y_i)\) e</li>
<li>\(\forall j. 1 \leq j \leq i - 1. \lambda \in first(Y_j)\) então \(a \in first(A)\).</li>

</ul>

</section>
<section id="slide-orgece3eb3">
<h3 id="orgece3eb3">First e Follow</h3>
<ul>
<li>Aplique estas regras enquanto for possível.</li>

</ul>

</section>
<section id="slide-org7bc485a">
<h3 id="org7bc485a">First e Follow</h3>
<ul>
<li>Calcular os conjuntos \(first\) para:</li>

</ul>

<div>
\begin{array}{lcl}
E  & \to & TE'\\
E' & \to & \textbf{+}TE'\,|\,\lambda\\
T  & \to & FT' \\
T' & \to & \textbf{*}FT'\,|\,\lambda\\
F  & \to & \textbf{(}E\textbf{)}\,|\,\textbf{id}
\end{array}

</div>

</section>
<section id="slide-org814856f">
<h3 id="org814856f">First e Follow</h3>
<ul>
<li>\(first(E) = first(T) = first(F)\)</li>

<li>\(first(F) = \{\textbf{(}, \textbf{id}\}\)</li>

</ul>

</section>
<section id="slide-org93eff87">
<h3 id="org93eff87">First e Follow</h3>
<ul>
<li>\(first(E') = \{\textbf{+},\lambda\}\)</li>

<li>\(first(T') = \{\textbf{*},\lambda\}\)</li>

</ul>

</section>
<section id="slide-org606a2cb">
<h3 id="org606a2cb">First e Follow</h3>
<ul>
<li>$ \(\in follow(P)\)</li>

<li>Se \(A \to \alpha B \beta \in R\) então:</li>

</ul>

<div>
\begin{array}{l}
first(\beta) - \{\lambda\} \subseteq follow(B)
\end{array}

</div>

</section>
<section id="slide-orgd70bbb3">
<h3 id="orgd70bbb3">First e Follow</h3>
<ul>
<li>Se \(A \to \alpha B\) ou \(A \to \alpha B \beta\), em que \(\lambda \in first(\beta)\) então:</li>

</ul>

<div>
\begin{array}{l}
follow(A) \subseteq follow(B)
\end{array}

</div>

</section>
<section id="slide-org3526d2d">
<h3 id="org3526d2d">First e Follow</h3>
<ul>
<li>Aplique estas regras enquanto possível.</li>

</ul>

</section>
<section id="slide-orgea20b4b">
<h3 id="orgea20b4b">First e Follow</h3>
<ul>
<li>Calcular os conjuntos \(follow\) para:</li>

</ul>

<div>
\begin{array}{lcl}
E  & \to & TE'\\
E' & \to & \textbf{+}TE'\,|\,\lambda\\
T  & \to & FT' \\
T' & \to & \textbf{*}FT'\,|\,\lambda\\
F  & \to & \textbf{(}E\textbf{)}\,|\,\textbf{id}
\end{array}

</div>


</section>
<section id="slide-org089d590">
<h3 id="org089d590">First e Follow</h3>
<ul>
<li>$ \(\in follow(E)\):
<ul>
<li>\(E\) é a variável inicial da gramática.</li>

</ul></li>

</ul>

</section>
<section id="slide-org263b799">
<h3 id="org263b799">First e Follow</h3>
<ul>
<li>\textbf{)} \(\in follow(E)\):
<ul>
<li>Devido a produção \(F \to (E)\)</li>
<li>Regra: \(A \to \alpha B \beta\) então \(first(\beta) \subseteq follow(B)\).
<ul>
<li>Neste caso, \(\beta = \textbf{)}\)</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org76454bf">
<h3 id="org76454bf">First e Follow</h3>
<ul>
<li>Logo, temos que $follow(E) = \{\textbf{)},\\(\}\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3b27a1f">
<h2 id="org3b27a1f">Implementação em Haskell</h2>
<div class="outline-text-2" id="text-org3b27a1f">
</div>
</section>
<section id="slide-org65f5666">
<h3 id="org65f5666">Implementação em Haskell</h3>
<ul>
<li>Representando terminais</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Terminal</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">T</span> <span style="color: #ce537a; font-weight: bold;">String</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Dollar</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span>
</pre>
</div>

</section>
<section id="slide-org806f9b8">
<h3 id="org806f9b8">Implementação em Haskell</h3>
<ul>
<li>Representando não terminais</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">NT</span> <span style="color: #ce537a; font-weight: bold;">String</span>
</pre>
</div>

</section>
<section id="slide-org3792c0a">
<h3 id="org3792c0a">Implementação em Haskell</h3>
<ul>
<li>Representando símbolos</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Symbol</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Var</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span>
  <span style="color: #7590db;">|</span> <span style="color: #ce537a; font-weight: bold;">Symb</span> <span style="color: #ce537a; font-weight: bold;">Terminal</span>
</pre>
</div>

</section>
<section id="slide-org457154b">
<h3 id="org457154b">Implementação em Haskell</h3>
<ul>
<li>Representando produções</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Production</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Prod</span> <span style="color: #4f97d7;">{</span>
      leftHand <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span>
    , rightHand <span style="color: #7590db;">::</span> <span style="color: #bc6ec5;">[</span><span style="color: #ce537a; font-weight: bold;">Symbol</span><span style="color: #bc6ec5;">]</span>
    <span style="color: #4f97d7;">}</span> 
</pre>
</div>

</section>
<section id="slide-org2d1fc64">
<h3 id="org2d1fc64">Implementação em Haskell</h3>
<ul>
<li>Representando gramáticas</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">data</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span>
  <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #4f97d7;">{</span>
      productions <span style="color: #7590db;">::</span> <span style="color: #bc6ec5;">[</span><span style="color: #ce537a; font-weight: bold;">Production</span><span style="color: #bc6ec5;">]</span>
    , start       <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span>
    <span style="color: #4f97d7;">}</span>
</pre>
</div>

</section>
<section id="slide-orgf838cba">
<h3 id="orgf838cba">Implementação em Haskell</h3>
<ul>
<li>Representação de ponto fixo.</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">fixpoint</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Eq</span> a <span style="color: #7590db;">=&gt;</span> <span style="color: #4f97d7;">(</span>a <span style="color: #7590db;">-&gt;</span> a<span style="color: #4f97d7;">)</span> <span style="color: #7590db;">-&gt;</span> a <span style="color: #7590db;">-&gt;</span> a
<span style="color: #bc6ec5; font-weight: bold;">fixpoint</span> f x <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">let</span> x' <span style="color: #7590db;">=</span> f x
               <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7; font-weight: bold;">if</span> x <span style="color: #7590db;">==</span> x' <span style="color: #4f97d7; font-weight: bold;">then</span> x
                  <span style="color: #4f97d7; font-weight: bold;">else</span> fixpoint f x'
</pre>
</div>

</section>
<section id="slide-orgca21eae">
<h3 id="orgca21eae">Implementação em Haskell</h3>
<ul>
<li>Definição de tabela de first.</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #4f97d7; font-weight: bold;">type</span> <span style="color: #ce537a; font-weight: bold;">First</span> <span style="color: #7590db;">=</span> <span style="color: #ce537a; font-weight: bold;">Map</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #4f97d7;">]</span>

<span style="color: #bc6ec5; font-weight: bold;">merge</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">First</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #4f97d7;">]</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span>
<span style="color: #bc6ec5; font-weight: bold;">merge</span> m nt ts <span style="color: #7590db;">=</span> Map.insertWith union nt ts m

<span style="color: #bc6ec5; font-weight: bold;">firstSetFor</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Nonterminal</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">firstSetFor</span> nt m
  <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">case</span> Map.lookup nt m <span style="color: #4f97d7; font-weight: bold;">of</span>
      <span style="color: #ce537a; font-weight: bold;">Nothing</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7; font-weight: bold;">[]</span>
      <span style="color: #ce537a; font-weight: bold;">Just</span> ts <span style="color: #7590db;">-&gt;</span> ts
</pre>
</div>

</section>
<section id="slide-org810a712">
<h3 id="org810a712">Implementação em Haskell</h3>
<ul>
<li>Cálculo de first</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">first</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Nonterminal</span>, <span style="color: #2d9574;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #2d9574;">]</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">first</span> g <span style="color: #7590db;">=</span> Map.toList m
  <span style="color: #4f97d7; font-weight: bold;">where</span>
     m <span style="color: #7590db;">=</span> fixpoint <span style="color: #4f97d7;">(</span>stepFirst g<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">(</span>first0 g<span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orge957a55">
<h3 id="orge957a55">Implementação em Haskell</h3>
<ul>
<li>Cálculo de first0</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">first0</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span>
<span style="color: #bc6ec5; font-weight: bold;">first0</span> g <span style="color: #7590db;">=</span> Map.fromList <span style="color: #7590db;">$</span> map f <span style="color: #4f97d7;">(</span>nonterminals g<span style="color: #4f97d7;">)</span>
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    f nt <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">(</span>nt , <span style="color: #bc6ec5; font-weight: bold;">[]</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orgfaf7c5e">
<h3 id="orgfaf7c5e">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto first</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">stepFirst</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span>
<span style="color: #bc6ec5; font-weight: bold;">stepFirst</span> g current
  <span style="color: #7590db;">=</span> step' <span style="color: #4f97d7;">(</span>productions g<span style="color: #4f97d7;">)</span> current
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    step' <span style="color: #4f97d7; font-weight: bold;">[]</span> curr <span style="color: #7590db;">=</span> curr
    step' <span style="color: #4f97d7;">(</span>p<span style="color: #ce537a; font-weight: bold;">:</span>ps<span style="color: #4f97d7;">)</span> curr
      <span style="color: #7590db;">=</span> merge <span style="color: #4f97d7;">(</span>step' ps curr<span style="color: #4f97d7;">)</span>
              <span style="color: #4f97d7;">(</span>leftHand p<span style="color: #4f97d7;">)</span>
              <span style="color: #4f97d7;">(</span>terminalsForRHS p<span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orgfcf8491">
<h3 id="orgfcf8491">Implementação em Haskell</h3>
<ul>
<li>Definição de <code>terminalsForRHS</code></li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">terminalsForRHS</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Production</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">terminalsForRHS</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Prod</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #bc6ec5; font-weight: bold;">[]</span><span style="color: #4f97d7;">)</span> <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Lambda</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">terminalsForRHS</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Prod</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #bc6ec5;">[</span><span style="color: #ce537a; font-weight: bold;">Symb</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span> <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Lambda</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">terminalsForRHS</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Prod</span> x <span style="color: #bc6ec5;">(</span>yj <span style="color: #ce537a; font-weight: bold;">:</span> ys<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
  <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">case</span>  yj <span style="color: #4f97d7; font-weight: bold;">of</span>
      <span style="color: #ce537a; font-weight: bold;">Symb</span> terminal <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span>terminal<span style="color: #4f97d7;">]</span>
      <span style="color: #ce537a; font-weight: bold;">Var</span> nonterminal <span style="color: #7590db;">-&gt;</span>
         <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span> <span style="color: #7590db;">`elem`</span> first_iminus1 <span style="color: #4f97d7; font-weight: bold;">then</span>
            terminalsForYj <span style="color: #7590db;">`union`</span> terminalsForRHS <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Prod</span> x ys<span style="color: #4f97d7;">)</span>
         <span style="color: #4f97d7; font-weight: bold;">else</span>
            terminalsForYj
      <span style="color: #4f97d7; font-weight: bold;">where</span>
         first_iminus1 <span style="color: #7590db;">=</span> firstSetFor nonterminal current
         terminalsForYj <span style="color: #7590db;">=</span> filter <span style="color: #4f97d7;">(</span><span style="color: #7590db;">/=</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span><span style="color: #4f97d7;">)</span> first_iminus1
</pre>
</div>

</section>
<section id="slide-org9dd0fce">
<h3 id="org9dd0fce">Implementação em Haskell</h3>
<ul>
<li>Extensão de first para palavras</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">firstForWord</span> <span style="color: #7590db;">::</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Symbol</span><span style="color: #4f97d7;">]</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">firstForWord</span> <span style="color: #4f97d7;">[</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Var</span> nt<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span> ft <span style="color: #7590db;">=</span> firstSetFor nt ft
<span style="color: #bc6ec5; font-weight: bold;">firstForWord</span> <span style="color: #4f97d7;">[</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Symb</span> t<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span>t<span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">firstForWord</span> <span style="color: #4f97d7;">(</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Var</span> nt<span style="color: #bc6ec5;">)</span> <span style="color: #ce537a; font-weight: bold;">:</span> ss<span style="color: #4f97d7;">)</span> ft <span style="color: #7590db;">=</span>
  <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span> <span style="color: #7590db;">`elem`</span> firstSetFor nt ft <span style="color: #4f97d7; font-weight: bold;">then</span> 
        firstMinusLambda <span style="color: #7590db;">`union`</span> firstForWord ss ft
  <span style="color: #4f97d7; font-weight: bold;">else</span> firstMinusLambda
       <span style="color: #4f97d7; font-weight: bold;">where</span> firstMinusLambda <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span>x <span style="color: #7590db;">|</span> x <span style="color: #7590db;">&lt;-</span> firstSetFor nt ft, x <span style="color: #7590db;">/=</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">firstForWord</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">[]</span>
</pre>
</div>

</section>
<section id="slide-orge1048e7">
<h3 id="orge1048e7">Implementação em Haskell</h3>
<ul>
<li>Implementação de follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">follow</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #4f97d7;">[</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">Nonterminal</span>, <span style="color: #2d9574;">[</span><span style="color: #ce537a; font-weight: bold;">Terminal</span><span style="color: #2d9574;">]</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span>
<span style="color: #bc6ec5; font-weight: bold;">follow</span> g
  <span style="color: #7590db;">=</span> Map.toList <span style="color: #7590db;">$</span> fixpoint <span style="color: #4f97d7;">(</span>stepFollow g m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">(</span>follow0 g<span style="color: #4f97d7;">)</span>
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    m <span style="color: #7590db;">=</span> Map.fromList <span style="color: #7590db;">$</span> first g
</pre>
</div>

</section>
<section id="slide-org87138c1">
<h3 id="org87138c1">Implementação em Haskell</h3>
<ul>
<li>Inicialização de follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">follow0</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Follow</span>
<span style="color: #bc6ec5; font-weight: bold;">follow0</span> g <span style="color: #7590db;">=</span> Map.fromList <span style="color: #7590db;">$</span> map f <span style="color: #4f97d7;">(</span>nonterminals g<span style="color: #4f97d7;">)</span>
  <span style="color: #4f97d7; font-weight: bold;">where</span>
    f nt <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">if</span> nt <span style="color: #7590db;">==</span> start g <span style="color: #4f97d7; font-weight: bold;">then</span> <span style="color: #4f97d7;">(</span>nt, <span style="color: #bc6ec5;">[</span><span style="color: #ce537a; font-weight: bold;">Dollar</span><span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #4f97d7;">(</span>nt, <span style="color: #bc6ec5; font-weight: bold;">[]</span><span style="color: #4f97d7;">)</span>
</pre>
</div>

</section>
<section id="slide-orgbd10dcf">
<h3 id="orgbd10dcf">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">stepFollow</span> <span style="color: #7590db;">::</span> <span style="color: #ce537a; font-weight: bold;">Grammar</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">First</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Follow</span> <span style="color: #7590db;">-&gt;</span> <span style="color: #ce537a; font-weight: bold;">Follow</span>
<span style="color: #bc6ec5; font-weight: bold;">stepFollow</span> g firstG current
  <span style="color: #7590db;">=</span> step' <span style="color: #4f97d7;">(</span>productions g<span style="color: #4f97d7;">)</span> firstG current
    <span style="color: #4f97d7; font-weight: bold;">where</span>
      step' <span style="color: #4f97d7; font-weight: bold;">[]</span> <span style="color: #4f97d7; font-weight: bold;">_</span> curr <span style="color: #7590db;">=</span> curr
      step' <span style="color: #4f97d7;">(</span>p <span style="color: #ce537a; font-weight: bold;">:</span> ps<span style="color: #4f97d7;">)</span> fG curr
        <span style="color: #7590db;">=</span> mergeTerminals p <span style="color: #4f97d7;">(</span>step' ps fG curr<span style="color: #4f97d7;">)</span>
       <span style="color: #4f97d7; font-weight: bold;">where</span>
         <span style="color: #7590db;">...</span>
</pre>
</div>

</section>
<section id="slide-org8209429">
<h3 id="org8209429">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">mergeTerminals</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Prod</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #bc6ec5; font-weight: bold;">[]</span><span style="color: #4f97d7;">)</span> <span style="color: #7590db;">=</span> undefined
<span style="color: #bc6ec5; font-weight: bold;">mergeTerminals</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Prod</span> l <span style="color: #bc6ec5;">(</span>s <span style="color: #ce537a; font-weight: bold;">:</span> ss<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> <span style="color: #7590db;">=</span> merge' l <span style="color: #4f97d7; font-weight: bold;">[]</span> s ss
</pre>
</div>

</section>
<section id="slide-org9ac4e61">
<h3 id="org9ac4e61">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #bc6ec5; font-weight: bold;">merge'</span> a <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Var</span> b<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">[]</span> fMinus1
  <span style="color: #7590db;">=</span> merge fMinus1 b <span style="color: #4f97d7;">(</span>followSetFor a fMinus1<span style="color: #4f97d7;">)</span>
<span style="color: #bc6ec5; font-weight: bold;">merge'</span> <span style="color: #4f97d7; font-weight: bold;">_</span> <span style="color: #4f97d7; font-weight: bold;">_</span>  <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Symb</span> <span style="color: #4f97d7; font-weight: bold;">_</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7; font-weight: bold;">[]</span> fMinus1 <span style="color: #7590db;">=</span> fMinus1
<span style="color: #bc6ec5; font-weight: bold;">merge'</span> a w1 <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Symb</span> t<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">(</span>w2 <span style="color: #ce537a; font-weight: bold;">:</span> w2s<span style="color: #4f97d7;">)</span> fMinus1
 <span style="color: #7590db;">=</span> merge' a <span style="color: #4f97d7;">(</span>w1 <span style="color: #7590db;">++</span> <span style="color: #bc6ec5;">[</span><span style="color: #ce537a; font-weight: bold;">Symb</span> t<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span> w2 w2s fMinus1
<span style="color: #bc6ec5; font-weight: bold;">merge'</span> a w1 nt<span style="color: #7590db;">@</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Var</span> b<span style="color: #4f97d7;">)</span> w2<span style="color: #7590db;">@</span><span style="color: #4f97d7;">(</span>w21 <span style="color: #ce537a; font-weight: bold;">:</span> w2s<span style="color: #4f97d7;">)</span> fMinus1
  <span style="color: #7590db;">=</span> merge <span style="color: #4f97d7;">(</span>merge' a <span style="color: #bc6ec5;">(</span>w1 <span style="color: #7590db;">++</span> <span style="color: #2d9574;">[</span>nt<span style="color: #2d9574;">]</span><span style="color: #bc6ec5;">)</span> w21 w2s fMinus1<span style="color: #4f97d7;">)</span> b new
    <span style="color: #4f97d7; font-weight: bold;">where</span>
       firstW2 <span style="color: #7590db;">=</span> <span style="color: #4f97d7;">[</span>x <span style="color: #7590db;">|</span> x <span style="color: #7590db;">&lt;-</span> firstForWord w2 fG, x <span style="color: #7590db;">/=</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span><span style="color: #4f97d7;">]</span>
       new <span style="color: #7590db;">=</span> <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #ce537a; font-weight: bold;">Lambda</span> <span style="color: #7590db;">`elem`</span> firstForWord w2 fG <span style="color: #4f97d7; font-weight: bold;">then</span>
                followSetFor a fMinus1 <span style="color: #7590db;">`union`</span> firstW2
              <span style="color: #4f97d7; font-weight: bold;">else</span> firstForWord w2 fG
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orgd19a0c9">
<h2 id="orgd19a0c9">Concluindo</h2>
<div class="outline-text-2" id="text-orgd19a0c9">
</div>
</section>
<section id="slide-orgb27eeae">
<h3 id="orgb27eeae">Concluindo</h3>
<ul>
<li>Nesta aula, apresentamos os conjuntos first e follow.</li>

<li>Apresentamos uma implementação simples em Haskell de funções para calcular estes conjuntos.</li>

</ul>

</section>
<section id="slide-org00eaa31">
<h3 id="org00eaa31">Concluindo</h3>
<ul>
<li>Próxima aula: Análise sintática LL(1)</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgbf2f0a8">
<h2 id="orgbf2f0a8">Exercícios</h2>
<div class="outline-text-2" id="text-orgbf2f0a8">
</div>
</section>
<section id="slide-org37e0b68">
<h3 id="org37e0b68">Exercícios</h3>
<ul>
<li>Utilizando a representação de gramáticas utilizada para obter os conjuntos first e follow,
implemente uma função para obter o conjunto de não terminais anuláveis de uma gramática.
Dizemos que um não terminal é anulável se ele deriva &lambda; em um ou mais passos de derivação.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/rodrigo/reveal.js/dist/reveal.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/markdown/markdown.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/notes/notes.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/search/search.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'convex',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
