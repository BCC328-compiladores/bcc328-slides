<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Conjuntos first e follow</title>
<meta name="author" content="Construção de compiladores I"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/rodrigo/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="file:///home/rodrigo/reveal.js/dist/theme/white.css" id="theme"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Conjuntos first e follow</h1><h2 class="author">Construção de compiladores I</h2>
</section>


<section>
<section id="slide-org31bd69b">
<h2 id="org31bd69b">Objetivos</h2>
<div class="outline-text-2" id="text-org31bd69b">
</div>
</section>
<section id="slide-orgd28fda8">
<h3 id="orgd28fda8">Objetivos</h3>
<ul>
<li>Apresentar os conjuntos first e follow e seu uso para definir gramáticas LL(1)</li>

<li>Apresentar uma implementação de first e follow em Haskell.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org558e05a">
<h2 id="org558e05a">Gramáticas LL(1)</h2>
<div class="outline-text-2" id="text-org558e05a">
</div>
</section>
<section id="slide-orgb6cd431">
<h3 id="orgb6cd431">Gramáticas LL(1)</h3>
<ul>
<li>Classe de gramáticas que admitem analisadores sem backtracking</li>

<li>LL(1) significa
<ul>
<li>*L*eft to right: entrada analisada da esquerda para direita.</li>
<li>*L*eft most derivation: construção de derivação mais a esquerda.</li>
<li>Uso de <b>1</b> token da entrada para decidir a derivação.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgebd4290">
<h3 id="orgebd4290">Gramáticas LL(1)</h3>
<ul>
<li>Como determinar se uma gramática é LL(1)?
<ul>
<li>Vamos usar os conjuntos First e Follow.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org9da0b62">
<h2 id="org9da0b62">First e Follow</h2>
<div class="outline-text-2" id="text-org9da0b62">
</div>
</section>
<section id="slide-org37590bb">
<h3 id="org37590bb">First e Follow</h3>
<ul>
<li>\(first(\alpha)\): conjunto de terminais que iniciam sentenças derivadas a partir de \(\alpha\).</li>

<li>\(\alpha \in (V\cup \Sigma)^*\).</li>

</ul>

</section>
<section id="slide-orgf24e356">
<h3 id="orgf24e356">First e Follow</h3>
<ul>
<li>\(follow(A)\): conjunto de terminais que aparecem logo a direita de \(A\) em alguma derivação.</li>

<li>\(A \in V\).</li>

</ul>

</section>
<section id="slide-orge4900f2">
<h3 id="orge4900f2">First e Follow</h3>
<ul>
<li>\(first(a) = \{a\}\), se \(a \in \Sigma\).</li>
<li>\(\lambda\in first(A)\) se \(A\to\lambda \in R\).</li>

</ul>

</section>
<section id="slide-org9a9e175">
<h3 id="org9a9e175">First e Follow</h3>
<ul>
<li>Se \(A \in V\) e</li>
<li>\(A \to Y_1\,Y_2\,...\,Y_k \in R\) e</li>
<li>\(a\in first(Y_i)\) e</li>
<li>\(\forall j. 1 \leq j \leq i - 1. \lambda \in first(Y_j)\) então \(a \in first(A)\).</li>

</ul>

</section>
<section id="slide-org085c042">
<h3 id="org085c042">First e Follow</h3>
<ul>
<li>Aplique estas regras enquanto for possível.</li>

</ul>

</section>
<section id="slide-orgc73cd13">
<h3 id="orgc73cd13">First e Follow</h3>
<ul>
<li>Calcular os conjuntos \(first\) para:</li>

</ul>

<div>
\begin{array}{lcl}
E  & \to & TE'\\
E' & \to & \textbf{+}TE'\,|\,\lambda\\
T  & \to & FT' \\
T' & \to & \textbf{*}FT'\,|\,\lambda\\
F  & \to & \textbf{(}E\textbf{)}\,|\,\textbf{id}
\end{array}

</div>

</section>
<section id="slide-org5956888">
<h3 id="org5956888">First e Follow</h3>
<ul>
<li>\(first(E) = first(T) = first(F)\)</li>

<li>\(first(F) = \{\textbf{(}, \textbf{id}\}\)</li>

</ul>

</section>
<section id="slide-orgaa8f8c2">
<h3 id="orgaa8f8c2">First e Follow</h3>
<ul>
<li>\(first(E') = \{\textbf{+},\lambda\}\)</li>

<li>\(first(T') = \{\textbf{*},\lambda\}\)</li>

</ul>

</section>
<section id="slide-orge487711">
<h3 id="orge487711">First e Follow</h3>
<ul>
<li>$ \(\in follow(P)\)</li>

<li>Se \(A \to \alpha B \beta \in R\) então:</li>

</ul>

<div>
\begin{array}{l}
first(\beta) - \{\lambda\} \subseteq follow(B)
\end{array}

</div>

</section>
<section id="slide-orgf7d1d77">
<h3 id="orgf7d1d77">First e Follow</h3>
<ul>
<li>Se \(A \to \alpha B\) ou \(A \to \alpha B \beta\), em que \(\lambda \in first(\beta)\) então:</li>

</ul>

<div>
\begin{array}{l}
follow(A) \subseteq follow(B)
\end{array}

</div>

</section>
<section id="slide-org92b7f48">
<h3 id="org92b7f48">First e Follow</h3>
<ul>
<li>Aplique estas regras enquanto possível.</li>

</ul>

</section>
<section id="slide-org84b58be">
<h3 id="org84b58be">First e Follow</h3>
<ul>
<li>Calcular os conjuntos \(follow\) para:</li>

</ul>

<div>
\begin{array}{lcl}
E  & \to & TE'\\
E' & \to & \textbf{+}TE'\,|\,\lambda\\
T  & \to & FT' \\
T' & \to & \textbf{*}FT'\,|\,\lambda\\
F  & \to & \textbf{(}E\textbf{)}\,|\,\textbf{id}
\end{array}

</div>


</section>
<section id="slide-org5835b61">
<h3 id="org5835b61">First e Follow</h3>
<ul>
<li>$ \(\in follow(E)\):
<ul>
<li>\(E\) é a variável inicial da gramática.</li>

</ul></li>

</ul>

</section>
<section id="slide-org24b3aa9">
<h3 id="org24b3aa9">First e Follow</h3>
<ul>
<li>\textbf{)} \(\in follow(E)\):
<ul>
<li>Devido a produção \(F \to (E)\)</li>
<li>Regra: \(A \to \alpha B \beta\) então \(first(\beta) \subseteq follow(B)\).
<ul>
<li>Neste caso, \(\beta = \textbf{)}\)</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org148e680">
<h3 id="org148e680">First e Follow</h3>
<ul>
<li>Logo, temos que $follow(E) = \{\textbf{)},\\(\}\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org4a683f8">
<h2 id="org4a683f8">Implementação em Haskell</h2>
<div class="outline-text-2" id="text-org4a683f8">
</div>
</section>
<section id="slide-orge8ed8c7">
<h3 id="orge8ed8c7">Implementação em Haskell</h3>
<ul>
<li>Representando terminais</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">Terminal</span>
  <span style="color: #715ab1;">=</span> <span style="color: #ba2f59; font-weight: bold;">T</span> <span style="color: #ba2f59; font-weight: bold;">String</span>
  <span style="color: #715ab1;">|</span> <span style="color: #ba2f59; font-weight: bold;">Dollar</span>
  <span style="color: #715ab1;">|</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span>
</pre>
</div>

</section>
<section id="slide-org98e5f48">
<h3 id="org98e5f48">Implementação em Haskell</h3>
<ul>
<li>Representando não terminais</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span>
  <span style="color: #715ab1;">=</span> <span style="color: #ba2f59; font-weight: bold;">NT</span> <span style="color: #ba2f59; font-weight: bold;">String</span>
</pre>
</div>

</section>
<section id="slide-org5d33cf5">
<h3 id="org5d33cf5">Implementação em Haskell</h3>
<ul>
<li>Representando símbolos</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">Symbol</span>
  <span style="color: #715ab1;">=</span> <span style="color: #ba2f59; font-weight: bold;">Var</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span>
  <span style="color: #715ab1;">|</span> <span style="color: #ba2f59; font-weight: bold;">Symb</span> <span style="color: #ba2f59; font-weight: bold;">Terminal</span>
</pre>
</div>

</section>
<section id="slide-org084b533">
<h3 id="org084b533">Implementação em Haskell</h3>
<ul>
<li>Representando produções</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">Production</span>
  <span style="color: #715ab1;">=</span> <span style="color: #ba2f59; font-weight: bold;">Prod</span> <span style="color: #3a81c3;">{</span>
      leftHand <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span>
    , rightHand <span style="color: #715ab1;">::</span> <span style="color: #6c3163;">[</span><span style="color: #ba2f59; font-weight: bold;">Symbol</span><span style="color: #6c3163;">]</span>
    <span style="color: #3a81c3;">}</span> 
</pre>
</div>

</section>
<section id="slide-orgba16ab3">
<h3 id="orgba16ab3">Implementação em Haskell</h3>
<ul>
<li>Representando gramáticas</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span>
  <span style="color: #715ab1;">=</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #3a81c3;">{</span>
      productions <span style="color: #715ab1;">::</span> <span style="color: #6c3163;">[</span><span style="color: #ba2f59; font-weight: bold;">Production</span><span style="color: #6c3163;">]</span>
    , start       <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span>
    <span style="color: #3a81c3;">}</span>
</pre>
</div>

</section>
<section id="slide-orgb292613">
<h3 id="orgb292613">Implementação em Haskell</h3>
<ul>
<li>Representação de ponto fixo.</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">fixpoint</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Eq</span> a <span style="color: #715ab1;">=&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> a<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> a <span style="color: #715ab1;">-&gt;</span> a
<span style="color: #6c3163; font-weight: bold;">fixpoint</span> f x <span style="color: #715ab1;">=</span> <span style="color: #3a81c3; font-weight: bold;">let</span> x' <span style="color: #715ab1;">=</span> f x
               <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3; font-weight: bold;">if</span> x <span style="color: #715ab1;">==</span> x' <span style="color: #3a81c3; font-weight: bold;">then</span> x
                  <span style="color: #3a81c3; font-weight: bold;">else</span> fixpoint f x'
</pre>
</div>

</section>
<section id="slide-org11a56f4">
<h3 id="org11a56f4">Implementação em Haskell</h3>
<ul>
<li>Definição de tabela de first.</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">First</span> <span style="color: #715ab1;">=</span> <span style="color: #ba2f59; font-weight: bold;">Map</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #3a81c3;">]</span>

<span style="color: #6c3163; font-weight: bold;">merge</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">First</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #3a81c3;">]</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span>
<span style="color: #6c3163; font-weight: bold;">merge</span> m nt ts <span style="color: #715ab1;">=</span> Map.insertWith union nt ts m

<span style="color: #6c3163; font-weight: bold;">firstSetFor</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Nonterminal</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">firstSetFor</span> nt m
  <span style="color: #715ab1;">=</span> <span style="color: #3a81c3; font-weight: bold;">case</span> Map.lookup nt m <span style="color: #3a81c3; font-weight: bold;">of</span>
      <span style="color: #ba2f59; font-weight: bold;">Nothing</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3; font-weight: bold;">[]</span>
      <span style="color: #ba2f59; font-weight: bold;">Just</span> ts <span style="color: #715ab1;">-&gt;</span> ts
</pre>
</div>

</section>
<section id="slide-org1063064">
<h3 id="org1063064">Implementação em Haskell</h3>
<ul>
<li>Cálculo de first</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">first</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span><span style="color: #6c3163;">(</span><span style="color: #ba2f59; font-weight: bold;">Nonterminal</span>, <span style="color: #2d9574;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">first</span> g <span style="color: #715ab1;">=</span> Map.toList m
  <span style="color: #3a81c3; font-weight: bold;">where</span>
     m <span style="color: #715ab1;">=</span> fixpoint <span style="color: #3a81c3;">(</span>stepFirst g<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span>first0 g<span style="color: #3a81c3;">)</span>
</pre>
</div>

</section>
<section id="slide-orgfa43c02">
<h3 id="orgfa43c02">Implementação em Haskell</h3>
<ul>
<li>Cálculo de first0</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">first0</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span>
<span style="color: #6c3163; font-weight: bold;">first0</span> g <span style="color: #715ab1;">=</span> Map.fromList <span style="color: #715ab1;">$</span> map f <span style="color: #3a81c3;">(</span>nonterminals g<span style="color: #3a81c3;">)</span>
  <span style="color: #3a81c3; font-weight: bold;">where</span>
    f nt <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">(</span>nt , <span style="color: #6c3163; font-weight: bold;">[]</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

</section>
<section id="slide-orgaf67093">
<h3 id="orgaf67093">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto first</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">stepFirst</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span>
<span style="color: #6c3163; font-weight: bold;">stepFirst</span> g current
  <span style="color: #715ab1;">=</span> step' <span style="color: #3a81c3;">(</span>productions g<span style="color: #3a81c3;">)</span> current
  <span style="color: #3a81c3; font-weight: bold;">where</span>
    step' <span style="color: #3a81c3; font-weight: bold;">[]</span> curr <span style="color: #715ab1;">=</span> curr
    step' <span style="color: #3a81c3;">(</span>p<span style="color: #ba2f59; font-weight: bold;">:</span>ps<span style="color: #3a81c3;">)</span> curr
      <span style="color: #715ab1;">=</span> merge <span style="color: #3a81c3;">(</span>step' ps curr<span style="color: #3a81c3;">)</span>
              <span style="color: #3a81c3;">(</span>leftHand p<span style="color: #3a81c3;">)</span>
              <span style="color: #3a81c3;">(</span>terminalsForRHS p<span style="color: #3a81c3;">)</span>
</pre>
</div>

</section>
<section id="slide-org01eeeb2">
<h3 id="org01eeeb2">Implementação em Haskell</h3>
<ul>
<li>Definição de <code>terminalsForRHS</code></li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">terminalsForRHS</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Production</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">terminalsForRHS</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Prod</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #6c3163; font-weight: bold;">[]</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Lambda</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">terminalsForRHS</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Prod</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #6c3163;">[</span><span style="color: #ba2f59; font-weight: bold;">Symb</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Lambda</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">terminalsForRHS</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Prod</span> x <span style="color: #6c3163;">(</span>yj <span style="color: #ba2f59; font-weight: bold;">:</span> ys<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
  <span style="color: #715ab1;">=</span> <span style="color: #3a81c3; font-weight: bold;">case</span>  yj <span style="color: #3a81c3; font-weight: bold;">of</span>
      <span style="color: #ba2f59; font-weight: bold;">Symb</span> terminal <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span>terminal<span style="color: #3a81c3;">]</span>
      <span style="color: #ba2f59; font-weight: bold;">Var</span> nonterminal <span style="color: #715ab1;">-&gt;</span>
         <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span> <span style="color: #715ab1;">`elem`</span> first_iminus1 <span style="color: #3a81c3; font-weight: bold;">then</span>
            terminalsForYj <span style="color: #715ab1;">`union`</span> terminalsForRHS <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Prod</span> x ys<span style="color: #3a81c3;">)</span>
         <span style="color: #3a81c3; font-weight: bold;">else</span>
            terminalsForYj
      <span style="color: #3a81c3; font-weight: bold;">where</span>
         first_iminus1 <span style="color: #715ab1;">=</span> firstSetFor nonterminal current
         terminalsForYj <span style="color: #715ab1;">=</span> filter <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">/=</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span><span style="color: #3a81c3;">)</span> first_iminus1
</pre>
</div>

</section>
<section id="slide-org215a64e">
<h3 id="org215a64e">Implementação em Haskell</h3>
<ul>
<li>Extensão de first para palavras</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">firstForWord</span> <span style="color: #715ab1;">::</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Symbol</span><span style="color: #3a81c3;">]</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">firstForWord</span> <span style="color: #3a81c3;">[</span><span style="color: #6c3163;">(</span><span style="color: #ba2f59; font-weight: bold;">Var</span> nt<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span> ft <span style="color: #715ab1;">=</span> firstSetFor nt ft
<span style="color: #6c3163; font-weight: bold;">firstForWord</span> <span style="color: #3a81c3;">[</span><span style="color: #6c3163;">(</span><span style="color: #ba2f59; font-weight: bold;">Symb</span> t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">[</span>t<span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">firstForWord</span> <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span><span style="color: #ba2f59; font-weight: bold;">Var</span> nt<span style="color: #6c3163;">)</span> <span style="color: #ba2f59; font-weight: bold;">:</span> ss<span style="color: #3a81c3;">)</span> ft <span style="color: #715ab1;">=</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span> <span style="color: #715ab1;">`elem`</span> firstSetFor nt ft <span style="color: #3a81c3; font-weight: bold;">then</span> 
        firstMinusLambda <span style="color: #715ab1;">`union`</span> firstForWord ss ft
  <span style="color: #3a81c3; font-weight: bold;">else</span> firstMinusLambda
       <span style="color: #3a81c3; font-weight: bold;">where</span> firstMinusLambda <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">[</span>x <span style="color: #715ab1;">|</span> x <span style="color: #715ab1;">&lt;-</span> firstSetFor nt ft, x <span style="color: #715ab1;">/=</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">firstForWord</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #715ab1;">=</span> <span style="color: #3a81c3; font-weight: bold;">[]</span>
</pre>
</div>

</section>
<section id="slide-org41dfb97">
<h3 id="org41dfb97">Implementação em Haskell</h3>
<ul>
<li>Implementação de follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">follow</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">[</span><span style="color: #6c3163;">(</span><span style="color: #ba2f59; font-weight: bold;">Nonterminal</span>, <span style="color: #2d9574;">[</span><span style="color: #ba2f59; font-weight: bold;">Terminal</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">follow</span> g
  <span style="color: #715ab1;">=</span> Map.toList <span style="color: #715ab1;">$</span> fixpoint <span style="color: #3a81c3;">(</span>stepFollow g m<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span>follow0 g<span style="color: #3a81c3;">)</span>
  <span style="color: #3a81c3; font-weight: bold;">where</span>
    m <span style="color: #715ab1;">=</span> Map.fromList <span style="color: #715ab1;">$</span> first g
</pre>
</div>

</section>
<section id="slide-org0f4f74d">
<h3 id="org0f4f74d">Implementação em Haskell</h3>
<ul>
<li>Inicialização de follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">follow0</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Follow</span>
<span style="color: #6c3163; font-weight: bold;">follow0</span> g <span style="color: #715ab1;">=</span> Map.fromList <span style="color: #715ab1;">$</span> map f <span style="color: #3a81c3;">(</span>nonterminals g<span style="color: #3a81c3;">)</span>
  <span style="color: #3a81c3; font-weight: bold;">where</span>
    f nt <span style="color: #715ab1;">=</span> <span style="color: #3a81c3; font-weight: bold;">if</span> nt <span style="color: #715ab1;">==</span> start g <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #3a81c3;">(</span>nt, <span style="color: #6c3163;">[</span><span style="color: #ba2f59; font-weight: bold;">Dollar</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3;">(</span>nt, <span style="color: #6c3163; font-weight: bold;">[]</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

</section>
<section id="slide-org228729b">
<h3 id="org228729b">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">stepFollow</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Grammar</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">First</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Follow</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Follow</span>
<span style="color: #6c3163; font-weight: bold;">stepFollow</span> g firstG current
  <span style="color: #715ab1;">=</span> step' <span style="color: #3a81c3;">(</span>productions g<span style="color: #3a81c3;">)</span> firstG current
    <span style="color: #3a81c3; font-weight: bold;">where</span>
      step' <span style="color: #3a81c3; font-weight: bold;">[]</span> <span style="color: #3a81c3; font-weight: bold;">_</span> curr <span style="color: #715ab1;">=</span> curr
      step' <span style="color: #3a81c3;">(</span>p <span style="color: #ba2f59; font-weight: bold;">:</span> ps<span style="color: #3a81c3;">)</span> fG curr
        <span style="color: #715ab1;">=</span> mergeTerminals p <span style="color: #3a81c3;">(</span>step' ps fG curr<span style="color: #3a81c3;">)</span>
       <span style="color: #3a81c3; font-weight: bold;">where</span>
         <span style="color: #715ab1;">...</span>
</pre>
</div>

</section>
<section id="slide-orgd91b91e">
<h3 id="orgd91b91e">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">mergeTerminals</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Prod</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #6c3163; font-weight: bold;">[]</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> undefined
<span style="color: #6c3163; font-weight: bold;">mergeTerminals</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Prod</span> l <span style="color: #6c3163;">(</span>s <span style="color: #ba2f59; font-weight: bold;">:</span> ss<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> merge' l <span style="color: #3a81c3; font-weight: bold;">[]</span> s ss
</pre>
</div>

</section>
<section id="slide-orgdd519c9">
<h3 id="orgdd519c9">Implementação em Haskell</h3>
<ul>
<li>Iteração do conjunto follow</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">merge'</span> a <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Var</span> b<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">[]</span> fMinus1
  <span style="color: #715ab1;">=</span> merge fMinus1 b <span style="color: #3a81c3;">(</span>followSetFor a fMinus1<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">merge'</span> <span style="color: #3a81c3; font-weight: bold;">_</span> <span style="color: #3a81c3; font-weight: bold;">_</span>  <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Symb</span> <span style="color: #3a81c3; font-weight: bold;">_</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">[]</span> fMinus1 <span style="color: #715ab1;">=</span> fMinus1
<span style="color: #6c3163; font-weight: bold;">merge'</span> a w1 <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Symb</span> t<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span>w2 <span style="color: #ba2f59; font-weight: bold;">:</span> w2s<span style="color: #3a81c3;">)</span> fMinus1
 <span style="color: #715ab1;">=</span> merge' a <span style="color: #3a81c3;">(</span>w1 <span style="color: #715ab1;">++</span> <span style="color: #6c3163;">[</span><span style="color: #ba2f59; font-weight: bold;">Symb</span> t<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span> w2 w2s fMinus1
<span style="color: #6c3163; font-weight: bold;">merge'</span> a w1 nt<span style="color: #715ab1;">@</span><span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Var</span> b<span style="color: #3a81c3;">)</span> w2<span style="color: #715ab1;">@</span><span style="color: #3a81c3;">(</span>w21 <span style="color: #ba2f59; font-weight: bold;">:</span> w2s<span style="color: #3a81c3;">)</span> fMinus1
  <span style="color: #715ab1;">=</span> merge <span style="color: #3a81c3;">(</span>merge' a <span style="color: #6c3163;">(</span>w1 <span style="color: #715ab1;">++</span> <span style="color: #2d9574;">[</span>nt<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span> w21 w2s fMinus1<span style="color: #3a81c3;">)</span> b new
    <span style="color: #3a81c3; font-weight: bold;">where</span>
       firstW2 <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">[</span>x <span style="color: #715ab1;">|</span> x <span style="color: #715ab1;">&lt;-</span> firstForWord w2 fG, x <span style="color: #715ab1;">/=</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span><span style="color: #3a81c3;">]</span>
       new <span style="color: #715ab1;">=</span> <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #ba2f59; font-weight: bold;">Lambda</span> <span style="color: #715ab1;">`elem`</span> firstForWord w2 fG <span style="color: #3a81c3; font-weight: bold;">then</span>
                followSetFor a fMinus1 <span style="color: #715ab1;">`union`</span> firstW2
              <span style="color: #3a81c3; font-weight: bold;">else</span> firstForWord w2 fG
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org148df5d">
<h2 id="org148df5d">Concluindo</h2>
<div class="outline-text-2" id="text-org148df5d">
</div>
</section>
<section id="slide-org1560fb8">
<h3 id="org1560fb8">Concluindo</h3>
<ul>
<li>Nesta aula, apresentamos os conjuntos first e follow.</li>

<li>Apresentamos uma implementação simples em Haskell de funções para calcular estes conjuntos.</li>

</ul>

</section>
<section id="slide-orgf079cbd">
<h3 id="orgf079cbd">Concluindo</h3>
<ul>
<li>Próxima aula: Análise sintática LL(1)</li>

</ul>


</section>
</section>
<section>
<section id="slide-org67459bc">
<h2 id="org67459bc">Exercícios</h2>
<div class="outline-text-2" id="text-org67459bc">
</div>
</section>
<section id="slide-org49db267">
<h3 id="org49db267">Exercícios</h3>
<ul>
<li>Utilizando a representação de gramáticas utilizada para obter os conjuntos first e follow,
implemente uma função para obter o conjunto de não terminais anuláveis de uma gramática.
Dizemos que um não terminal é anulável se ele deriva &lambda; em um ou mais passos de derivação.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="file:///home/rodrigo/reveal.js/dist/reveal.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/markdown/markdown.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/notes/notes.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/search/search.js"></script>
<script src="file:///home/rodrigo/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'convex',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
